# vim: set ft=sh ai si ts=4 sw=4 et :
# $Id$
#
# My personal Bourne-style Shell resource configuration profile.
#
#
 

#
# default file permissions -rw------- / drwx------
#
umask 077

#
# hostname -s is not portable enough for getting the short form of our
# current machines hostname, so do this instead of invoking hostname -s
# whenever needed. At least this is more efficient then `hostname -s`...
#
HOSTNAME="`echo ${HOSTNAME:-\`hostname\`} | sed 's/\..*//'`"
export HOSTNAME

#
# set my standard environment settings
#

    #
    # the system should provide a suitable PATH for what we need here, 
    # avoid setting it here if we can, and let the site_shrc worry later.
    #
    if [ -z "$PATH" ]; then
        PATH="/bin:/sbin:/usr/bin:/usr/sbin"; export PATH
    fi

    # my standard issue prompt  (overriden later, based on $SHELL)
    PS1="${USER}@${HOSTNAME}-$ "; export PS1

    # locale related settings   (DEFAULT)
    TZ='Etc/UTC'; export TZ                 # my time zone
    LANG='en_US.UTF-8'; export LANG         # language.encoding
    # some programs require us to set LC_ALL manually as well.
    LC_ALL='en_US.UTF-8'; export LC_ALL
    MM_CHARSET='UTF-8'; export MM_CHARSET

    # prefer megabytes over 512 byte blocks.
    BLOCKSIZE='M'; export BLOCKSIZE

    # set my pager
    if [ -x /usr/bin/less ]; then
        PAGER='/usr/bin/less'; export PAGER
    else
        PAGER="more"; export PAGER
    fi
    LESS='-FiJqX'; export LESS  # default options to less

    # set my default editor, on order of preference and create aliases
    if [ -x /usr/local/bin/vim ]; then
        EDITOR='/usr/local/bin/vim'
        VISUAL='/usr/local/bin/vim'
    elif [ -x /usr/bin/vi ]; then
        EDITOR='/usr/bin/vi'
        VISUAL='/usr/bin/vi'
        # on some systems where vim is not installed, I tend to type vim
        alias vim='/usr/bin/vi'
    elif [ -x /usr/bin/mg -o /usr/local/bin/mg ]; then
        EDITOR="`which mg`"
        VISUAL="`which mg`"
        # alias to normal uemacs name if it is available
        which uemacs > /dev/null && alias uemacs='mg'
    else
        EDITOR=/bin/ed
        VISUAL=""
    fi
    export EDITOR VISUAL

#
# Adaopt self based on OS
#
    case `uname -s` in
        'FreeBSD') isFreeBSD=1
                   LSCOLORS='CxGxxxxxBxexExcxdx'; export LSCOLORS
                   ;; # FreeBSD
        'OpenBSD') isOpenBSD=1

                    # OpenBSD seems to lack the UTF-8 locale, so fall back
                    LANG='en_US.ISO8859-1'; export LANG
                    LC_ALL='en_US.ISO8859-1'; export LC_ALL
                    MM_CHARSET='ISO8859-1'; export MM_CHARSET
                   ;; # OpenBSD
        'NetBSD')  isNetBSD=1;;
        'Linux')   isLinux=1;;
        'Unix')    isUnix=1;;
        'Interix') isUnix=1;;   # treat Microsoft SFU as generic UNIX
        CYGWIN_NT*) isCygwin=1;;
    esac

#
# set shell specific settings
#
    case `basename $SHELL` in
        'sh') # older versions of the sh lack line editing (i.e. < sys 3)
            if [ $isFreeBSD -o $isOpenBSD -o $isNetBSD -o $isLinux ]; then
                set -o emacs
            fi
            ;; # sh
        'bash') 
            set bell-style none
            set -o emacs 
            set -o ignoreeof

            # prompt is: [ user@host:pwd ]$
            PS1="[ \u@\h:\w ]$ "; export PS1

            HISTFILE="${HOME}/.bash_history"
            ;; # bash
        'ksh' | 'pdksh' | 'mksh' | 'ksh88' | 'ksh93')
            set -o emacs 
            set -o ignoreeof

            # As used by the classic  korn shell
            HISTFILE="${HOME}/.sh_history"

            #
            # Check if we're using a public domain ksh, which supports the 
            # nifty 'bind' command, plus an extended command set
            #
            echo $KSH_VERSION | egrep 'MIRBSD|PD KSH' >/dev/null
            if [ $? -eq 0 ]; then 
                # assume we have a pd-style korn

                # the pdksh won't accept $'\eEscape's and requires the
                # old escape the escapes trick (see pdksh manual for PS1)
                #
                PS1="${USER}\e[1;37m@${HOSTNAME}\e[0;36m$\e[0;0m "

                #
                # make sure tab completion works (where possible)
                # XXX do not use complete-{command,file} - they break it!
                #
                bind "^I=complete"
                # needed to display the completion list, where applicable.
                bind "^I=complete-list"
            else
                # assume we have a real korn
    
                # the regular ksh needs $'\eEscapes'
                # ksh93 doesn't need the old escape the escapes to get the
                # line length right, but ksh88 might? Either way, ksh93
                # doesn't mind if they are there.
                #
                PS1="${USER}$'\e[1;37m'@${HOSTNAME}$'\e[0;36m'$ $'\e[0;0m'"

                #
                # define a function (keybind) that we can use to map keys.
                # this will only work on Korn Shell 1993 & up
                #
                typeset -A Keytable
                trap 'eval "${Keytable[${.sh.edchar}]}"' KEYBD
                keybind() { # key [action]
                    typeset key=$(print -f "%q" "$2")
                    case $# in
                        2) Keytable[$1]=' .sh.edchar=${.sh.edmode}'"$key" ;;
                        1) unset Keytable[$1] ;;
                        *) print -u2 "Usage: $0 key [action]"
                           return 2;; # usage errors return 2 by default
                    esac
                }
                # allow one <tab> to do completion work.
                #keybind $'\t' $'\E\E' #<-- use this if shell uses <esc><esc>
                keybind $'\t' $'\t\t'  #<-- use this if shell uses <tab><tab>

                # clear the screen on ^L    (control char)
                # rather then just reprinting the prompt.
                keybind  $'clear\n'
            fi
            ;; # ksh family
        'zsh') # set my various options
            HISTFILE="${HOME}/.histfile"
            HISTSIZE=768
            SAVEHIST=512
            setopt appendhistory autocd extendedglob 
            setopt incappendhistory
            # dont' beep !
            unsetopt beep
            # emacs bindings
            bindkey -e
            # use vi ^W behaviour rather then emacs mode default
            bindkey "^W" vi-backward-kill-word
            zstyle :compinstall filename "$HOME/.zshrc"
            autoload -Uz compinit
            compinit
            # I like color in my zsh prompt ;-)
            fg_no_colour=$'%{\e[0m%}'
            fg_green=$'%{\e[0;32m%}'
            PS1="${USER}@%B%m%b${fg_green}$ ${fg_no_colour}"; export PS1
            # display the (24h) time in the right-prompt`
            RPS1="%T"; export RPS1
    esac

#
# define some standard aliases for programs, should be fairly portable where
# said programs are installed.
#
    alias   bye='echo "bye"; exit'
    [ -n "$isFreeBSD" ] && alias bc='bc -q'
    alias   cls='clear'
    alias   copy='cp -i'
    alias   del='rm -i'
    alias   igrep='grep -i'
    alias   limeric='fortune /usr/share/games/fortune/limerick'
    alias   move='mv -i'
    alias   pd='perldoc'
    alias   pgr='$PAGER'
    #
    # Gee, it is so nice how *BSD lint's so often do the inverse
    # of SUSv2 when given a standard switch.
    #
    if [ -n "$isFreeBSD" ]; then
        alias   lint='lint -a -aa -ceghnuxz'
    elif [ -n "$isNetBSD" ]; then
        echo "Make an alias for lint"
    elif [ -n "$isOpenBSD" ]; then
        alias    lint='lint -ceghnuxz'
    elif [ -n "$isLinux" ]; then
        echo "Make an alias for lint"
    fi
    #
    # useful aliases for various version control systems
    #
    alias cvs-st='cvs status | grep -i Status:'
    # also see function `cvs-ci`

#
# define system specfic aliases for various commands
#
    if [ $isFreeBSD ]; then
        # The FreeBSD system seems to have been made by people that have an "Hey
        # we've been using this command prompt for the past 30 years, let's
        # make it comfortable!" approch...  Thus it needs it's own set of
        # aliases.

        alias   ls='ls -FGHh'
        alias   ll='ls -laFhHo'
        alias   la='ls -aFGh'

        # OpenBSD calls Exuberant Ctags 'ectags', allow both
        alias   ectags=exctags

        # system specific alias for displaying temps
        alias   temp='sysctl hw.acpi.thermal | egrep "tz.*\.temperature"'

        # quick command to mute/unmute the sound system
        mute() {
            OLD_VOLUME=`mixer -s`
            mixer vol 0:0 pcm 0:0

        }
        unmute() {
            # XXX FreeBSDs mixer command requires an EOF terminated argument
            # list. `echo $old` or `cat tmpfile` will work.
            mixer `echo $OLD_VOLUME` $*
        }
    elif [ $isNetBSD ]; then
        # NetBSD calls Exuberant Ctags 'ectags', but I want the FreeBSD name
        alias   exctags=ectags
    elif [ $isOpenBSD ]; then
        # note, -h added in OpenBSD 3.4
        alias 	ls='ls -Fh'
        alias 	ll='ls -laFho'
        alias 	la='ls -aFh'
        # OpenBSD calls Exuberant Ctags 'ectags', but I want the FreeBSD name
        alias   exctags=ectags
    elif [ $isLinux ]; then 
        alias 	ls='ls -Fh'
        alias 	ll='ls -laFho'
        alias 	la='ls -aFh'
    elif [ $isCygwin ]; then
        echo "Using Cygwin compatible aliases"
    else
        echo "Using POSIX/SUS based generic UNIX aliases"
        #
        # define fail safe aliases that should work on most systems
        #
        alias   ls='ls -FH'
        alias   ll='ls -laFHo'
        alias   la='ls -aF'
    fi

#
# General functions
#

# quick test of each name server on unix box.
test-dns() {
    for IP in `cat /etc/resolv.conf | awk '/^nameserver/ { print $2 }'`
    do
        ping -c ${1:-3} "$IP" | tail -n 1
    done
}

# create a new script, with the shebang! pre-inserted.
# @params $1 = interp; $2 = filename
new-script() {
    echo '#!/usr/bin/env' " $1\n\n" >> $2
}

# start new live journal post in editor
# @params $1 = optional directory
lj-post() {
    ${EDITOR} "${1:-/tmp}/lj-$$.post" || echo "$0: error?"
}

# commit short message (string) to file, after expanding c escapes
# @parms $1 = "file:\n\tmessage"
cvs-ci() {
    if [ -z "$1" ]; then
        echo "$0: No commit message specified: aborting"
        exit 1;
    fi

    # XXX some old bourne shells don't support local but those
    # that I know don't, also don't have shell functions either!
    #
    local ECHOCMD=""
    local CVSMSGF=`mktemp -t cvs-ci`

    # some shells built in echo won't expand control char without -e
    #
    if [ "$isFreeBSD" -a "`basename $SHELL`" = 'sh' ] || \
       [ "`basename $SHELL`" = "bash" ] ; then

        ECHOCMD="echo -e \"$1\""
    else
        # a proper echo command is available
        ECHOCMD="echo \"$1\""
    fi
    eval "$ECHOCMD" > "$CVSMSGF"
    shift; cvs commit -F "$CVSMSGF" "$@"
}

#
# give a few fortune cookie and the current date/time on login
#
    [ -x /usr/games/fortune ] && /usr/games/fortune -aes
    echo ''; echo ''
    echo "To days date is: `date`"

#
# parse site local additions
#
    . ${HOME}/.site_shrc

