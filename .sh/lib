# vim: set ft=sh :
#
# This file is designed to be sourced for its functions.
#
# It is assumed to be apart of ~/.sh/* framework and can be sourced accordingly.
#
# You should be able to comply with assert_sh_services_environment() before
# executing any of these functions.
#

dump_path() {
    echo $PATH | sed -e 's/:/\n/g'
}

in_path() {
    #
    # usage: in_path [OPTION] WHAT...
    #
    # Searches PATH for WHAT.
    #
    # options: 
    #   
    #   -d = WHAT refers to directories. (Default.)
    #   -b = WHAT refers to programs.
    #
    # exit status:
    #   0	= found
    #   >0	= not found
    # 
    #
    local what bin dir prog option

    OPTIND=1
    while getopts "bedh" option; do
        case "$option" in
            b|e)
                bin=1
                ;;
            d)
                dir=1
                ;;
            h)
                echo "usage: in_path [-b | -d] NAME"
                echo "Check for  binary (-b) or directory (-d) in PATH."
                return
                ;;
            \?)
                # bad option
                return
                ;;
        esac
    done
    shift `expr $OPTIND - 1`

    # default to -d (directory).
    [ -z "$bin" -a -z "$dir" ] && dir=1

    if [ -n "$bin" ]; then
        for bin; do
            for dir in `dump_path`; do
                [ -x "${dir}/${bin}" ] && return 0
            done
        done
    elif [ -n "$dir" ]; then
        for dir; do
            dump_path | grep -q '^'"$dir"'$' && return 0
        done
    else
        echo "in_path: internal error!"
        return 127
    fi
}

append_path() {
    PATH="$PATH:$1"
}


prepend_path() {
    PATH="$1:$PATH"
}

ensure_path() {
    #
    # usage: ensure_path {path}
    #
    # Ensure that its argument is in path.
    #
    # options: 
    #   -a append (default).
    #   -e only if exists.
    #   -h help message.
    #   -p prepend.
    #
    local path aflag eflag pflag option
    OPTIND=1
    while getopts "aehp" option; do
        case "$option" in
            a)
                aflag=1
                ;;
            e)
                eflag=1
                ;;
            h)
                echo "usage: ensure_path [OPTION] PATH"
                return
                ;;
            p)
                pflag=1
                ;;
            \?)
                # bad option
                return
                ;;
        esac
    done
    shift `expr $OPTIND - 1`

    for path in $@; do

        # default to -a (append).
        [ -z "$pflag" -a -z "$aflag" ] && aflag=1

        # -e => only if exists.
        [ -n "$eflag" -a ! -d "$path" ] && return

        # already in path
        if in_path -d "$path"; then
            # echo "$path is in PATH"
            return
        fi


        if [ -n "$aflag" ]; then
            append_path "$path"
        elif [ -n "$pflag" ]; then
            prepend_path "$path"
        else
            echo "ensure_path: internal error!."
            return 1
        fi
    done

}


fuzzy_ensure_path() {
    #
    # usage: fuzzy_ensure_path [OPTION] BASEPATH...
    #
    # OPTION is the same as ensure_path.
    #
    # Given a BASEPATH like /usr/local/foo:
    #
    #   0. Check if /usr/local/foo/foo (or foo.sh) exists.
    #   2. Check if /usr/local/foo/bin/foo (or foo.sh) exists.
    #   3. Check if /usr/local/foo/(last dir by sort)/foo (or foo.sh) exists.
    #   4. Check if /usr/local/foo/(last dir by sort)/bin/foo (or foo.sh) exists.
    #
    # This is useful for things stored in groups, e.g. if you have a tree like
    #   /usr/local/foo/
    #       1.1
    #       1.2
    #       foo-1.3
    #       e.t.c.
    #
    # TODO:
    #
    #   -d foo,bar,... list of subdirs to check, e.g. -d sbin /usr/local/foo 
    #   -x sh,py,pl,... list of extensions to check, e.g. -x py /usr/local/foo
    #
    local basepath dirname binname trydir trysubdir exts tryext option flags

    OPTIND=1
    while getopts "b:aehp" option; do
        case "$option" in
            b)
                binname="$OPTARG"
                ;;
            h)
                echo "usage: fuzzy_ensure_path [OPTION] BASEPATH"
                return
                ;;
            \?)
                # bad option
                return
                ;;
            *)
                flags="$flags -$option"
                ;;
        esac
    done
    shift `expr $OPTIND - 1`

    for basepath in $@; do
        dirname="`dirname $basepath`"
        binname="${binname:-`basename $basepath`}"
        exts="sh py pl rb" 


        if [ -d "$basepath" ]; then
            for trydir in "${basepath}" "${basepath}/`ls ${basepath} | sort | tail -n 1`"; do
                for trysubdir in "$trydir" "${trydir}/bin"; do
                    if [ -x "${trysubdir}/${binname}" ]; then
                        ensure_path $flags "${trysubdir}"
                        return
                    fi
                    for tryext in $exts; do
                        if [ -x "${trysubdir}/${binname}.${tryext}" ]; then
                            ensure_path $flags "${trysubdir}"
                            return
                        fi
                    done
                done
                # echo "try $trydir/$binname"
                # echo "try $trydir/${binname}.sh"
                # echo "try $trydir/bin/${binname}"
                # echo "try $trydir/bin/${binname}.sh"
            done
        fi
    done
}

find_in_normpath() {
    #
    # Search in the usual paths for the indicated programs. If found print the
    # full path to the program to standard output.
    #
    # params: 
    #   $@  = a list of programs to search for
    #
    # exit status:
    #   0	= found
    #   >0	= not found
    #
    local progname p name

    for progname; do
        for p in "${HOME}/sw/sh.local" "${HOME}/sw/sh" "${HOME}/sw/bin" \
                  "${HOME}/sw/sbin" \
                  /usr/local/bin /usr/local/sbin \
                  /usr/bin /usr/sbin \
                  /bin /sbin
        do
            name="${p}/${progname}"
            if [ -x "$name" ]; then
                echo "$name"
                return 0
            fi
        done
        # echo "not found: $progname"
    done
    return 127
}

set_default_sh_services_environment() {
    #
    # Call for the side effect of setting a few vars to ~/.sh values.
    #

    MY_PROFILE_PATH="${HOME}/.sh"
    THIS_PROFILE="${MY_PROFILE_PATH}/this-profile"

    export MY_PROFILE_PATH THIS_PROFILE
    assert_sh_services_environment
}

maybe_set_default_sh_services_environment() {
    if ! check_sh_services_environment; then
        set_default_sh_services_environment
    fi
}

assert_sh_services_environment() {
    #
    # assert that the environment these functions need is exported
    #

    if ! check_sh_services_environment; then
        echo "sh services environment is missconfigured, abborting"
        exit 1
    fi
}

check_sh_services_environment() {
    #
    # check if the environment these functions need is exported
    # returns 0 if ok, > 0 if not ok
    #

    [ -z "$MY_PROFILE_PATH" ] && return 1
    [ -z "$THIS_PROFILE" ] && return 1
    return 0
}

services_d() {
    local w

    w="$MY_PROFILE_PATH/services.d/$1"
    shift 1
    if [ -x "${w}.`uname -n`" ]; then # use host-specific override if available
        w="${w}.`uname -n`"
    fi

	if [ -x "$w" ]; then
	    "$w" "$@"
	else
	    echo "no $1 profile to execute! ($w)"
	fi
}

make_profile_link() {
    local w

    w="${MY_PROFILE_PATH}/config.d/${1}.`echo_this_profile NETWORK_PROFILE`"
    if [ -f "$w" ]; then
        ln -sf "$w" "${HOME}/.$1"
        return 0
    else
        return 1
    fi
}

rm_profile_link() {
	if [ -L "${HOME}/.$1" ]; then
		unlink "${HOME}/.$1"
	fi
}

echo_this_profile() {
    #
    # extract info from the this-profile file.
    #
    # if no arguments: dump it sans comments.
    # for each argument (key), print the corrisonding value
    #

    local key

    if [ ! -r "$THIS_PROFILE" ]; then
        echo "unable to read $THIS_PROFILE" 1>&2
        return 127
    fi

    if [ $# -eq 0 ]; then
        cat "$THIS_PROFILE" | grep -v -E "^#"
        return 0;
    fi

    for key in $@; do
        grep -E "^${key}=" "$THIS_PROFILE"  | cut -d "=" -f 2- | tail -n 1
            #
            # force last entry (tail -n 1) to be returned, to *force* sanity.
            # there should never be duplicates unless the user dicked with it.
    done
}

write_this_profile() {
    local key value

    key="$1"
    value="$2"

    if [ -z "$key" ]; then
        echo "KEY should be a scalar word, not the empty string!"
        return 1
    fi

    # erase the key
    if [ -z "$value" ]; then
        ed -s "$THIS_PROFILE" >/dev/null <<EOF
    g/^${key}=/d
    w
    q
EOF
    fi

    # test if value already exists
    if [ -n "`echo_this_profile $key`" ]; then
        # and replace
        ed -s "$THIS_PROFILE" >/dev/null <<EOF
        #cat <<EOF
    $
    ?^${key}=?
    c
${key}=${value}
.
    w
    q
EOF
        return $?
    fi

    # else we can just append it.
    #
    # ed doesn't do locking so >> is just as safe \o/.
    #
    if [ -n "$value" ]; then
        echo "${key}=${value}" >> $THIS_PROFILE
    fi
}

get_ruby_version() {
    local p
    
    p="`find_in_normpath ruby`"
    [ -n "$p" ] && "$p" -v | cut -d ' ' -f 2
}

get_ruby_major_version() {
    get_ruby_version | cut -d '.' -f 1-2
}

get_python_version() {
    local p
    
    p="`find_in_normpath python`"
    # groan, python seems to use stderr here.
    [ -n "$p" ] && "$p" -V 2>&1 | cut -d ' ' -f 2
}

get_python_major_version() {
    get_python_version | cut -d '.' -f 1-2
}

get_power_state() {
    case "$OS_NAME" in
        Linux)
            ${OS_NAME}_get_power_state
            ;;
        *)
            echo "`basename $0`: unsupported platform: `uname -o` / OS_NAME=${OS_NAME}"
            return 127
            ;;
    esac
}

set_power_profile() {
    #
    # invokes ${MY_PROFILE_PATH}/power.d/{network profile}.{host name} with any
    # arguments given to us. The profile and arguments are recorded using
    # write_this_profile.
    #

    local hostname power_dir network_power_profile default_power_profile which_profile

    hostname="`uname -n`"
    power_dir="${MY_PROFILE_PATH}/power.d"
    network_power_profile="${power_dir}/`echo_this_profile  NETWORK_PROFILE`.$hostname"
    default_power_profile="${power_dir}/default.$hostname"

    if [ -x "$network_power_profile" ]; then
        which_profile="$network_power_profile"
    elif [ -x "$default_power_profile" ]; then
        which_profile="$default_power_profile"
    else
        echo "`basename $0`: no power profile available!" > /dev/stderr
        return 1
    fi

    "$which_profile" "$*" 
    write_this_profile POWER_PROFILE "`basename "$which_profile"` $*"
}



# Load OS specific library code if present.
#
    if [ -n "$OS_NAME" -a -f "${HOME}/.sh/lib.d/${OS_NAME}" ]; then
        . "${HOME}/.sh/lib.d/${OS_NAME}"
    fi

