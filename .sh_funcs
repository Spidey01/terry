#
# General functions that should be fairly portable
#
#

find_in_normpath() {
    #
    # Search in the usual paths for the indicated programs. If found print the
    # full path to the program to standard output, else print a nount found
    # message to standard output.
    #
    # params: 
    #   $@  = a list of programs to search for
    #
    # exit status:
    #   0	= found
    #   >0	= not found
    #
    local P
    local name
    local progname

    for progname; do
        for P in /bin /usr/bin /usr/local/bin "${HOME}/bin" "${HOME}/sh" \
                 /sbin /usr/sbin /usr/local/sbin "${HOME}/sbin"
        do
            name="${P}/${progname}"
            if [ -x "$name" ]; then
                echo "$name"
                continue 2
            fi
        done
        echo "not found: $progname"
    done
    return 127
}

find_in_normpaths() {
    #
    # Search in the usual paths for the indicated programs and set the 
    # indicated variables to that path, as would be suitable for exec.
    #
    # params: 
    #   $@  = a list of 'program VARIABLE' to search for
    #
    # exit status:
    #   0
    #
    local P

    if [ "$#" -eq 0 ]; then
        printf "$0 name [variable name variable...]\n"
        return 0
    fi
    while [ "$#" -ne 0 ]; do
        local varname="$1"
        local progname="$2"
        shift 2

        local P="`find_in_normpath $progname`"
        echo "$P" | grep "not found:" >/dev/null 2>/dev/null
        if [ $? -eq 0 ]; then
            echo "unable to set $varname"
        else
            eval ${varname}="$P"
            export ${varname}
        fi
    done

    return 0
}


test-dns() {
    #
    # quick test of each name server on unix box.
    #
    local IP
    for IP in `cat /etc/resolv.conf | awk '/^nameserver/ { print $2 }'`
    do
        ping -c ${1:-3} "$IP" | tail -n 1
    done
}

new-script() {
    #
    # create a new script, with the shebang! pre-inserted.
    #
    # params:
    #  $1   = interp
    #  $2   = filename
    #
    printf "#\!/usr/bin/env $1\n\n" >> $2
}

lj-post() {
    #
    # start new live journal post in editor
    #
    # params:
    #  $1   = optional directory
    #
    ${EDITOR} "${1:-/tmp}/lj-$$.post" || echo "$0: error?"
}

cvs-ci() {
    #
    # commit short message (string) to file, after expanding c escapes
    # parms:
    #  $1   = "file:\n\tmessage"
    #
    if [ -z "$1" ]; then
        echo "$0: No commit message specified: aborting"
        exit 1;
    fi

    # XXX some old bourne shells don't support local but those
    # that I know don't, also don't have shell functions either!
    #
    local ECHOCMD=""
    local CVSMSGF=`mktemp -t cvs-ci`

    # some shells built in echo won't expand control char without -e
    #
    printf "$1" > "$CVSMSGF"
    shift; cvs commit -F "$CVSMSGF" "$@"
}
