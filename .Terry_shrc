# vim: set ft=sh ai si ts=4 sw=4 et :
# $Id$
#
# My personal Bourne-style Shell resource configuration profile.
#
# $Revision$
# $Author$
#


#
# default file permissions -rw------- / drwx------
#
umask 077


#
# set my standard environment settings
#
    PATH="/bin:/sbin:/usr/bin:/usr/sbin"; export PATH

    # my standard issue prompt  (overriden later, based on $SHELL)
    PS1="$USER@`hostname -s`-$ "; export PS1

    # locale related settings   (DEFAULT)
    TZ='Etc/UTC'; export TZ                 # my time zone
    LANG='en_US.UTF-8'; export LANG         # language.encoding
    # some programs require us to set LC_ALL manually as well.
    LC_ALL='en_US.UTF-8'; export LC_ALL
    MM_CHARSET='UTF-8'; export MM_CHARSET

    # prefer megabytes over 512 byte blocks.
    BLOCKSIZE='M'; export BLOCKSIZE

    # set my pager
    if [ -x /usr/bin/less ]; then
        PAGER='/usr/bin/less'; export PAGER
    else
        PAGER="more"; export PAGER
    fi
    LESS='-FiJqX'; export LESS  # default options to less

    # set my default editor, on order of preference and create aliases
    if [ -x /usr/local/bin/vim ]; then
        EDITOR='/usr/local/bin/vim'; export EDITOR
        VISUAL='/usr/local/bin/vim'; export VISUAL
        #if [ -x /usr/local/bin/view ]; then
            # I prefer Vim to Vi when 'view'ing a file
        #   alias view='/usr/local/bin/view'
        #fi
    elif [ -x /usr/bin/vi ]; then
        EDITOR='/usr/bin/vi'; export EDITOR
        VISUAL='/usr/bin/vi'; export VISUAL
        # on some systems where vim is not installed, I tend to type vim
        alias vim='/usr/bin/vi'
    elif [ -x /usr/bin/mg -o /usr/local/bin/mg ]; then
        EDITOR="`which mg`"; export EDITOR
        VISUAL="`which mg`"; export VISUAL
        # alias to normal uemacs name if it is available
        which uemacs > /dev/null && alias uemacs='mg'
    fi

#
# Adaopt self based on OS
#
    case `uname -s` in
        'FreeBSD') isFreeBSD=1
                   LSCOLORS='CxGxxxxxBxexExcxdx'; export LSCOLORS
                   ;; # FreeBSD
        'OpenBSD') isOpenBSD=1

                    # OpenBSD seems to lack the UTF-8 locale, so fall back
                    LANG='en_US.ISO8859-1'; export LANG
                    LC_ALL='en_US.ISO8859-1'; export LC_ALL
                    MM_CHARSET='ISO8859-1'; export MM_CHARSET
                   ;; # OpenBSD
        'NetBSD')  isNetBSD=1;;
        'Linux')   isLinux=1;;
        'Unix')    isUnix=1;;
        'Interix') isUnix=1;;   # treat Microsoft SFU as generic UNIX
    esac

#
# set shell specific settings
#
    case `basename $SHELL` in
        'sh') # older versions of the sh lack line editing (i.e. < sys 3)
            if [ $isFreeBSD -o $isOpenBSD -o $isNetBSD -o $isLinux ]; then
                set -o emacs
            fi
            ;; # sh
        'bash') 
            # prompt is: [ user@host:pwd ]$
            PS1="[ \u@\h:\w ]$ "; export PS1
            set -o emacs
            HISTFILE="${HOME}/.bash_history"
            ;; # bash
        'ksh' | 'pdksh' | 'mksh' | 'ksh88' | 'ksh93')
            set -o emacs
            if [ -z "$isOpenBSD" ]; then
                PS1="${USER}$'\E[1;37m'@`hostname -s`$'\E[0;36m'$ $'\E[0;0m'"
            fi

            # As used by the classic  korn shell
            HISTFILE="${HOME}/.sh_history"

            #
            # Check if we're using a public domain ksh, which supports the 
            # nifty 'bind' command, plus an extended command set
            #
            echo $KSH_VERSION | egrep 'MIRBSD|PD KSH' >/dev/null
            if [ $? -eq 0 ]; then 
                # assume we have a pd-style korn

                #
                # make sure tab completion works (where possible)
                # XXX do not use complete-{command,file} - they break it!
                #
                bind "^I=complete"
                # needed to display the completion list, where applicable.
                bind "^I=complete-list"
            else
                # assume we have a real korn

                #
                # define a function (keybind) that we can use to map keys.
                # this will only work on Korn Shell 1993 & up
                #
                typeset -A Keytable
                trap 'eval "${Keytable[${.sh.edchar}]}"' KEYBD
                keybind() { # key [action]
                    typeset key=$(print -f "%q" "$2")
                    case $# in
                        2) Keytable[$1]=' .sh.edchar=${.sh.edmode}'"$key" ;;
                        1) unset Keytable[$1] ;;
                        *) print -u2 "Usage: $0 key [action]"
                           return 2;; # usage errors return 2 by default
                    esac
                }
                # allow one <tab> to do completion work.
                #keybind $'\t' $'\E\E' #<-- use this if shell uses <esc><esc>
                keybind $'\t' $'\t\t'  #<-- use this if shell uses <tab><tab>
            fi
            ;; # ksh family
        'zsh') # set my various options
            HISTFILE="${HOME}/.histfile"
            HISTSIZE=512
            SAVEHIST=384
            setopt appendhistory autocd extendedglob 
            setopt incappendhistory
            # dont' beep !
            unsetopt beep
            # emacs bindings
            bindkey -e
            zstyle :compinstall filename "$HOME/.zshrc"
            autoload -Uz compinit
            compinit
            # COLORS
            fg_green=$'%{\e[0;32m%}'
            fg_blue=$'%{\e[0;34m%}'
            fg_cyan=$'%{\e[0;36m%}'
            fg_red=$'%{\e[0;31m%}'
            fg_brown=$'%{\e[0;33m%}'
            fg_purple=$'%{\e[0;35m%}'
            fg_light_gray=$'%{\e[0;37m%}'
            fg_dark_gray=$'%{\e[1;30m%}'
            fg_light_blue=$'%{\e[1;34m%}'
            fg_light_green=$'%{\e[1;32m%}'
            fg_light_cyan=$'%{\e[1;36m%}' 
            fg_light_red=$'%{\e[1;31m%}'
            fg_light_purple=$'%{\e[1;35m%}'
            fg_no_colour=$'%{\e[0m%}'
            fg_white=$'%{\e[1;37m%}'
            fg_black=$'%{\e[0;30m%}'
            # I like color in my zsh prompt ;-)
            PS1="${USER}@%B%m%b${fg_green}$ ${fg_no_colour}"; export PS1
            # display the (24h) time in the right-prompt`
            RPS1="%T"; export RPS1
    esac

#
# define some standard aliases for programs, should be fairly portable where
# said programs are installed.
#
    alias   bye="echo 'bye'; exit"
    alias   cls='clear'
    alias   copy='cp -i'
    alias   del='rm -i'
    alias   igrep='grep -i'
    alias   limeric='fortune /usr/share/games/fortune/limerick'
    alias   move='mv -i'
    alias   pgr="$PAGER"
    #
    # Gee, it is so nice how *BSD lint's so often do the inverse
    # of SUSv2 when given a standard switch.
    #
    if [ ! -z "$isFreeBSD" ]; then
        alias   lint='lint -a -aa -ceghnuxz'
    elif [ ! -z "$isNetBSD" ]; then
        echo "Make an alias for lint"
    elif [ ! -z "$isOpenBSD" ]; then
        alias    lint='lint -ceghnuxz'
    elif [ ! -z "$isLinux" ]; then
        echo "Make an alias for lint"
    fi

#
# define system specfic aliases for common commands
#
    if [ $isFreeBSD ]; then
        # The FreeBSD system seems to have been made by people that have an "Hey
        # we've been using this command prompt for the past 30 years, let's
        # make it comfortable!" approch...  Thus it needs it's own set of
        # aliases.

        alias   cp='cp -ivRL'
        alias   mv='mv -v'
        alias   ls='ls -FGH'
        alias   ll='ls -laFhHo'
        alias   la='ls -aFG'
        alias   rm='rm -d'
        alias   rmdir='rmdir -v'

        # quick command to mute/unmute the sound system
        mute() {
            OLD_VOLUME=`mixer -s`
            mixer vol 0:0 pcm 0:0

        }
        unmute() {
            # XXX FreeBSDs mixer command requires an EOF terminated argument
            # list. `echo $old` or `cat tmpfile` will work.
            mixer `echo $OLD_VOLUME` $*
        }
    elif [ $isNetBSD ]; then
        echo "No aliases for NetBSD"
    elif [ $isOpenBSD ]; then
        alias 	cp='cp -iRL'
        alias 	ls='ls -F'
        alias 	ll='ls -laFho'
        alias 	la='ls -aF'
        alias 	rm='rm -d'
    elif [ $isLinux ]; then 
        echo "No aliases set..."
    else
        echo "Using POSIX/SUS based generic UNIX aliases"
        #
        # define fail safe aliases that should work on most systems
        #
        alias   ll='ls -l'
        alias   la='la'
    fi


#
# give a few fortune cookie and the current date/time on login
#
    [ -x /usr/games/fortune ] && /usr/games/fortune -aes
    echo ''; echo ''
    echo "To days date is: `date`"

#
# parse site local additions
#
    . ${HOME}/.site_shrc

