# vim: set ft=sh ai si ts=4 sw=4 et :
# $Id$
#
# My personal Bourne-style Shell resource configuration profile.
#
# This should be portable across virtually all Bourne shells and operating
# systems, as long as alias and functions are supported.
#
# portable functions are sourced from ~/.sh_funcs
#
# system specific functions are sourced from ~/.sh_funcs.osname
#
# .site_shrc is sourced after everything else, to privide system local changes.
#
#
 
. "${HOME}/.sh_funcs"

#
# default file permissions -rw------- / drwx------
#
umask 077


#
# Set a string of OS_* variables to the portable subset of uname outputs
#
OS_ARCH=`uname -m`
OS_NAME=`uname -s`
OS_RELLVL=`uname -r`

#
# Cache the current machines hostname. hostname -s is not portable enough for
# getting the short form of our current machines hostname, so do this instead
# of invoking hostname -s whenever needed. 
#
HOSTNAME="`echo ${HOSTNAME:-\`uname -n\`} | sed 's/\..*//'`"
export HOSTNAME

#
# set my standard environment settings
#

    #
    # the system should provide a suitable PATH for what we need here, 
    # avoid setting it here if we can, and let the site_shrc worry later.
    #
    if [ -z "$PATH" ]; then
        PATH="/bin:/sbin:/usr/bin:/usr/sbin"; export PATH
    fi

    # my standard issue prompt  (overriden later, based on $SHELL)
    PS1="${USER}@${HOSTNAME}-$ "; export PS1

    # Attempt to override default timezone; I prefer UTC
    TZ='Etc/UTC'; export TZ

    # prefer megabytes over 512 byte blocks.
    BLOCKSIZE='M'; export BLOCKSIZE

    # set my pager
    find_in_normpaths PAGER less 
    LESS='-FiJqX'  # default options to less
    export PAGER LESS

    #
    # set my default editor, if not found then go in on order of preference.
    #
    find_in_normpaths EDITOR vim >/dev/null
    if [ -z "$EDITOR" ]; then
        find_in_normpaths EDITOR nvi >/dev/null
    fi
    if [ -z "$EDITOR" ]; then
        find_in_normpaths EDITOR vi >/dev/null
    fi
    if [ -z "$EDITOR" ]; then
        find_in_normpaths EDITOR mg >/dev/null
    fi
    if [ -z "$EDITOR" ]; then
        find_in_normpaths EDITOR ed >/dev/null
    fi
    VISUAL="$EDITOR"; export VISUAL

#
# Adapt self based on OS
#
    case "$OS_NAME" in
        'FreeBSD') isFreeBSD=1
                   LSCOLORS='CxGxxxxxBxexExcxdx'; export LSCOLORS
                   ;; # FreeBSD
        'OpenBSD') isOpenBSD=1

                    # OpenBSD seems to lack the UTF-8 locale, so fall back
                    LANG='en_US.ISO8859-1'; export LANG
                    LC_ALL='en_US.ISO8859-1'; export LC_ALL
                    MM_CHARSET='ISO8859-1'; export MM_CHARSET
                   ;; # OpenBSD
        'NetBSD')  isNetBSD=1;;
        'Linux')   isLinux=1;;
        'Unix')    isUnix=1;;
        'Interix') isUnix=1;;   # treat Microsoft SFU as generic UNIX
        CYGWIN_NT*) isCygwin=1;;
    esac

#
# set shell specific settings
#
    case `basename $SHELL` in
        'sh') # older versions of the sh lack line editing (i.e. < sys 3)
            if [ $isFreeBSD -o $isOpenBSD -o $isNetBSD -o $isLinux ]; then
                set -o emacs
            fi
            # sh doesn't support C-style directory stacks, emulate them
            DIRSTACK="$HOME"
            export DIRSTACK
            alias dirs=emulate_dirs
            alias popd=emulate_popd
            alias pushd=emulate_pushd

            ;; # sh
        'bash') 
            set bell-style none
            set -o emacs 
            set -o ignoreeof
            shopt -s checkwinsize

            # list possible-completions instead of ring bell
            bind 'set show-all-if-ambiguous on'

            # prompt is: [ user@host:pwd ]$
            PS1="[ \u@\h:\w ]$ "; export PS1

            # append to history file rather than overwrite
            shopt -s histappend

            HISTFILE="${HOME}/.bash_history"
            ;; # bash
        'ksh' | 'pdksh' | 'mksh' | 'ksh88' | 'ksh93')
            set -o emacs 
            set -o ignoreeof

            #
            # The various korn shells handle escape codes in prompts 
            # rather differently from one another. This method appears
            # to work on all ksh implementations and plays nicely with
            # VT102 emulators like rxvt perfectly fine.
            #
            # Special thanks to Scotto for this technique.
            #
            PS1='${USER}@[1;37m${HOSTNAME}[0;36m$[0;0m '

            # As used by the classic  korn shell
            HISTFILE="${HOME}/.sh_history"

            #
            # Check if we're using a public domain ksh, which supports the 
            # nifty 'bind' command, plus an extended command set
            #
            echo $KSH_VERSION | egrep 'MIRBSD|PD KSH' >/dev/null
            if [ $? -eq 0 ]; then 
                # assume we have a pd-style korn

                #
                # make sure tab completion works (where possible)
                # XXX do not use complete-{command,file} - they break it!
                #
                bind "^I=complete"
                # needed to display the completion list, where applicable.
                bind "^I=complete-list"
            else
                # assume we have a real korn

                #
                # define a function (keybind) that we can use to map keys.
                # this will only work on Korn Shell 1993 & up
                #
                typeset -A Keytable
                trap 'eval "${Keytable[${.sh.edchar}]}"' KEYBD
                keybind() { # key [action]
                    typeset key=$(print -f "%q" "$2")
                    case $# in
                        2) Keytable[$1]=' .sh.edchar=${.sh.edmode}'"$key" ;;
                        1) unset Keytable[$1] ;;
                        *) print -u2 "Usage: $0 key [action]"
                           return 2;; # usage errors return 2 by default
                    esac

                }
                # allow one <tab> to do completion work.
                #keybind $'\t' $'\E\E' #<-- use this if shell uses <esc><esc>
                keybind $'\t' $'\t\t'  #<-- use this if shell uses <tab><tab>

                # clear the screen on ^L    (control char)
                # rather then just reprinting the prompt.
                keybind  $'clear\n'
            fi

            # ksh doesn't support C-style directory stacks, emulate them
            DIRSTACK="$HOME"
            export DIRSTACK
            alias dirs=emulate_dirs
            alias popd=emulate_popd
            alias pushd=emulate_pushd

            ;; # ksh family
        'zsh') # set my various options
            HISTFILE="${HOME}/.histfile"
            HISTSIZE=768
            SAVEHIST=512
            setopt appendhistory autocd extendedglob 
            setopt incappendhistory
            # dont' beep !
            unsetopt beep
            # emacs bindings
            bindkey -e
            # use vi ^W behaviour rather then emacs mode default
            bindkey "^W" vi-backward-kill-word
            zstyle :compinstall filename "$HOME/.zshrc"
            autoload -Uz compinit
            compinit
            # I like color in my zsh prompt ;-)
            fg_no_colour=$'%{\e[0m%}'
            fg_green=$'%{\e[0;32m%}'
            PS1="${USER}@%B%m%b${fg_green}$ ${fg_no_colour}"; export PS1
            # display the (24h) time in the right-prompt`
            RPS1="%T"; export RPS1
    esac


#
# parse platform specific functions
#
    [ -f "${HOME}/.sh_funcs.${OS_NAME}" ] && . "${HOME}/.sh_funcs.${OS_NAME}"

#
# define some standard aliases for programs. 
#
# These should be fairly portable where said programs are installed.
#
    alias   bye='echo "bye"; exit'
    [ -n "$isFreeBSD" ] && alias bc='bc -q'
    alias   cls='clear'
    alias   copy='cp -i'
    alias   del='rm -i'
    alias   igrep='grep -i'
    alias   limeric='fortune /usr/share/games/fortune/limerick'
    alias   move='mv -i'
    alias   pd='perldoc'
    alias   pgr='$PAGER'
    #
    # Gee, it is so nice how *BSD lint's so often do the inverse
    # of SUSv2 when given a standard switch.
    #
    if [ -n "$isFreeBSD" ]; then
        alias   lint='lint -a -aa -ceghnuxz'
    elif [ -n "$isNetBSD" ]; then
        echo "Make an alias for lint"
    elif [ -n "$isOpenBSD" ]; then
        alias    lint='lint -ceghnuxz'
    elif [ -n "$isLinux" ]; then
        echo "Make an alias for lint"
    fi
    #
    # useful aliases for various version control systems
    #
    alias cvs-st='cvs status | grep -i Status:'
    # also see function `cvs-ci`

#
# define system specfic aliases for various commands
#
    if [ $isFreeBSD ]; then
        # The FreeBSD system seems to have been made by people that have an "Hey
        # we've been using this command prompt for the past 30 years, let's
        # make it comfortable!" approch...  Thus it needs it's own set of
        # aliases.

        alias   ls='ls -FGHh'
        alias   ll='ls -laFhHo'
        alias   la='ls -aFGh'

        # OpenBSD calls Exuberant Ctags 'ectags', allow both
        alias   ectags=exctags

        # system specific alias for displaying temps
        alias   temp='sysctl hw.acpi.thermal | egrep "tz.*\.temperature"'
    elif [ $isNetBSD ]; then
        # NetBSD calls Exuberant Ctags 'ectags', but I want the FreeBSD name
        alias   exctags=ectags
    elif [ $isOpenBSD ]; then
        # note, -h added in OpenBSD 3.4
        alias 	ls='ls -Fh'
        alias 	ll='ls -laFho'
        alias 	la='ls -aFh'
        # OpenBSD calls Exuberant Ctags 'ectags', but I want the FreeBSD name
        alias   exctags=ectags
    elif [ $isLinux ]; then 
        alias 	ls='ls -Fh'
        alias 	ll='ls -laFho'
        alias 	la='ls -aFh'
    elif [ $isCygwin ]; then
        echo "Using Cygwin compatible aliases"
    else
        echo "Using POSIX/SUS based generic UNIX aliases"
        #
        # define fail safe aliases that should work on most systems
        #
        alias   ls='ls -FH'
        alias   ll='ls -laFHo'
        alias   la='ls -aF'
    fi


#
# give a few fortune cookie and the current date/time on login
#
    [ -x /usr/games/fortune ] && /usr/games/fortune -aes
    echo ''; echo ''
    echo "To days date is: `date`"

#
# parse site local additions
#
    [ -f "${HOME}/.site_shrc" ] && . "${HOME}/.site_shrc"

